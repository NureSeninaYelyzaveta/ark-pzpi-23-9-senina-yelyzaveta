 Міністерство освіти і науки України
 Харківський національний університет радіоелектроніки 
Кафедра програмної інженерії 









Лабораторна робота №4
 з дисципліни: «Аналіз та рефакторінг коду»
 на тему: «РОЗРОБКА IoT КЛІЄНТА 
(БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)»








Виконала: ст. гр. ПЗПІ-23-9
Сеніна Єлизавета Андріївна

Перевірив: Дашенков Дмитро Сергійович





 Харків 2025
	Розділ 1. Проєктування IoT-клієнта
	1.1. Призначення та концепція IoT-клієнта
	IoT-клієнт у рамках проєкту ArtProgress розробляється як програмний модуль, який відповідає за отримання, обробку та візуалізацію даних, що характеризують успішність учнів художніх шкіл. Головною метою клієнта є забезпечення користувача актуальною інформацією про оцінки, коментарі викладачів, участь учнів у виставках та інших творчих заходах.
	Прийнято рішення реалізувати IoT-клієнт у вигляді програмного симулятора на комп’ютері замість фізичного електронного табло або мікроконтролера. Це дозволяє зосередитися на основних завданнях лабораторної роботи — розробці бізнес-логіки та функцій налаштування клієнта, перевірці обробки даних та візуалізації результатів. Використання симулятора спрощує процес розробки та тестування, оскільки відсутні апаратні обмеження, а створений прототип залишається гнучким і його можна у майбутньому адаптувати для роботи з реальними IoT-пристроями без зміни алгоритмів обробки даних. 
	1.2. Необхідні дані та їх обробка
	Для ефективного функціонування IoT-клієнта необхідно визначити типи даних, які надходитимуть із серверної частини. Основними джерелами інформації є база даних системи ArtProgress та API серверу, що надає структуровані дані у форматі JSON. До ключових типів інформації належать оцінки за різні предмети, коментарі викладачів, відомості про участь учнів у виставках та творчих конкурсах, а також додаткові метадані про навчальний період, дисципліну та викладача.
	Отримані дані підлягають обробці на стороні клієнта. Обробка включає обчислення середніх балів за предметами, формування рейтингу учнів, визначення активності у виставках, а також підготовку інформації до візуалізації у зручному та наочному форматі. Таке рішення дозволяє не тільки забезпечити наочність, але й уникнути перевантаження користувача надмірною кількістю сирих даних.
	Важливо зазначити, що обробка даних відбувається локально у програмному симуляторі, що забезпечує швидкий доступ до інформації та можливість її налаштування. Користувач може задавати параметри відображення, змінювати інтервал оновлення даних та обирати, які саме дані демонструвати на екрані. Це рішення підвищує інтерактивність системи та дозволяє користувачу отримувати найбільш релевантну інформацію у режимі реального часу.
	1.3. Відображення інформації
	Відображення даних на екрані симулятора організовано таким чином, щоб максимально спростити сприйняття інформації. Основною формою подання є табличні дані, в яких відображаються оцінки учнів, середні бали, коментарі викладачів, участь у виставках та додаткові показники. Використання табличного формату обґрунтовано тим, що він забезпечує наочність та зручність порівняння результатів різних учнів, дисциплін і часових періодів.
	Графічні елементи, такі як кольорові позначки або прості іконки, використовуються для відображення участі у виставках та активності учнів. Це рішення дозволяє швидко оцінити успішність та активність учнів без необхідності аналізу великих обсягів текстової інформації. Інтерфейс передбачає можливість сортування та фільтрації даних за критеріями, що підвищує зручність користування та ефективність демонстрації результатів.
	1.4. Архітектура та взаємодія компонентів
	IoT-клієнт функціонує у рамках клієнт-серверної архітектури. Сервер надає дані через REST API, а клієнт приймає їх, обробляє та відображає у симуляторі. Ключовим рішенням є розділення процесів отримання, обробки та візуалізації даних. Це дозволяє окремо тестувати кожен етап, зменшувати складність коду та підвищувати його підтримуваність.
	Процес роботи клієнта включає декілька логічних етапів. На першому етапі відбувається запит даних до сервера та отримання актуальної інформації. На другому етапі відбувається обчислення показників, формування рейтингів та підготовка інформації до відображення. Третій етап полягає у візуалізації даних на екрані симулятора з дотриманням встановлених параметрів. Останній етап передбачає налаштування відображення користувачем, включно з вибором типів даних, інтервалом оновлення та форматом візуалізації.
	Завдяки такій архітектурі забезпечується безперервний моніторинг навчальних результатів учнів та демонстрація функціоналу системи, при цьому відсутність фізичного пристрою не обмежує можливості тестування та налаштування IoT-клієнта.

	Розділ 2. Моделювання функціональності IoT-клієнта
	Моделювання функціональності є ключовим етапом розробки програмного забезпечення, оскільки дозволяє заздалегідь визначити, як система взаємодіятиме з користувачами та зовнішніми компонентами, які дані буде обробляти і як їх відображати. Воно забезпечує логічну структуризацію функцій, дозволяє ідентифікувати критично важливі сценарії, оцінити можливі точки інтеграції та спростити тестування ще на етапі проектування. Особливо це актуально для IoT-рішень, де одночасно працюють користувачі, серверна частина та фізичні пристрої, і де необхідно забезпечити надійність, масштабованість та коректність обробки даних.
	2.1. UML-діаграма прецедентів IoT-клієнта
	Для комплексного розуміння функціональних можливостей IoT-клієнта та забезпечення ефективної організації його роботи використовується UML-діаграма прецедентів. Дана діаграма відображає ключові сценарії взаємодії користувачів та зовнішніх систем із клієнтом, що дозволяє наочно визначити обов’язкові та додаткові функції системи, а також взаємозв’язки між компонентами.
	Прецеденти обрані таким чином, щоб покривати всі критично важливі дії системи: керування користувачами, підключення до пристрою, збір даних, отримання сповіщень, візуалізація даних та надсилання команд. Це дозволяє відобразити не лише взаємодію користувача із системою, а й автоматизовану роботу клієнта із зовнішніми сервісами, що є характерним для IoT-рішень. Кожен прецедент демонструє окрему логічну функцію або серію операцій, необхідних для коректної роботи клієнта.
	Використання акторів, таких як Admin та User, а також зовнішніх систем — Cloud Service та IoT Device, обґрунтоване необхідністю моделювати як прямі дії користувача, так і взаємодію клієнта з серверною частиною та фізичними пристроями. Це дозволяє чітко виділити обов’язкові дії системи, які виконуються завжди, та додаткові функції, активовані за потреби, забезпечуючи гнучкість і масштабованість реалізації.
	Діаграма демонструє, що система не лише приймає дані і відображає їх користувачу, а й забезпечує логіку підготовки та обробки інформації, управління доступом та контроль взаємодії з зовнішніми компонентами. Такий підхід дозволяє легко ідентифікувати критичні сценарії використання, оцінити потенційні точки інтеграції та забезпечити коректну роботу бізнес-логіки, що особливо важливо для створення симулятора IoT-клієнта.


















Рисунок 2.1 — UML-діаграма прецедентів IoT-клієнта

	2.2. UML-діаграма діяльності IoT-клієнта
	Моделювання внутрішніх процесів системи є критично важливим етапом розробки IoT-клієнта, оскільки дозволяє детально описати послідовність дій, визначити логіку обробки даних та взаємодію користувача із системою. UML-діаграма діяльності слугує наочним інструментом для відображення цих процесів, забезпечуючи розуміння того, як різні компоненти системи взаємодіють між собою та з зовнішніми елементами.
	Діаграма діяльності IoT-клієнта системи ArtProgress демонструє послідовність внутрішніх процесів — від запуску симулятора до візуалізації та налаштування даних користувачем. Процес починається зі стартової точки, після чого система автоматично надсилає запит до сервера та перевіряє коректність отриманих даних. У разі некоректного отримання інформації відбувається повторний запит, що забезпечує надійність роботи клієнта.
	Після успішного отримання даних запускається паралельна обробка основних елементів: обчислення середніх оцінок та формування рейтингів учнів. Паралельна обробка дозволяє оптимізувати час виконання операцій і підготувати інформацію для подальшої візуалізації у зручному для користувача форматі. Злиття результатів цих процесів у єдиний потік гарантує послідовність і коректність даних, що відображаються на екрані.
	Завершальні етапи включають відображення даних на екрані симулятора та інтерактивне налаштування інтерфейсу користувачем, включаючи вибір типів даних, інтервал оновлення та формат подання інформації. Діаграма чітко розмежовує автоматичні дії системи та дії користувача, що дозволяє оцінити, які процеси виконуються самостійно, а які залежать від взаємодії з користувачем. Такий підхід забезпечує повне розуміння логіки роботи IoT-клієнта та сприяє ефективній розробці симулятора, тестуванню та подальшій адаптації під реальні пристрої.
















Рисунок 2.2 —діаграма діяльності IoT-клієнта 

	Моделювання функціональності IoT-клієнта на основі UML-діаграм прецедентів та діяльності дозволяє отримати цілісне уявлення про логіку роботи системи, послідовність обробки даних та взаємодію користувачів із системою. Завдяки UML-діаграмі прецедентів було чітко визначено ключові сценарії використання, обов’язкові та додаткові функції системи, а також взаємозв’язки між користувачами та зовнішніми компонентами. UML-діаграма діяльності дозволила деталізувати внутрішні процеси обробки даних, показати послідовність операцій і визначити точки, де відбувається взаємодія користувача з системою.
	Поєднання обох підходів забезпечує наочне та системне представлення роботи IoT-клієнта, дозволяє оцінити ефективність бізнес-логіки та взаємодію між компонентами, а також сприяє підготовці до наступних етапів розробки: реалізації програмного прототипу, налаштування інтерфейсу та тестування. Такий методичний підхід підвищує якість проектування, спрощує виявлення критичних сценаріїв та полегшує інтеграцію майбутніх модулів або розширень системи.

Розділ 3. Розробка бізнес-логіки IoT-клієнта
	Розробка бізнес-логіки IoT-клієнта є визначальним етапом створення системи, оскільки саме на рівні бізнес-логіки формуються правила обробки даних, алгоритми взаємодії з користувачем та підготовки інформації до візуалізації. Даний етап забезпечує послідовність виконання операцій, контроль цілісності даних та інтеграцію різних модулів системи. Бізнес-логіка виступає основою функціонування програмного симулятора, який моделює роботу реального IoT-клієнта, і визначає взаємозв’язок між отриманими даними, обчисленнями та відображенням результатів на екрані користувача.
	3.1. Алгоритми обробки даних
	Алгоритми обробки даних у IoT-клієнті побудовані з урахуванням потреб системи у швидкому та надійному формуванні показників успішності учнів. Основним завданням алгоритмів є обробка оцінок, коментарів та метаданих, що надходять із серверної частини через REST API. Після отримання даних клієнт виконує перевірку їх коректності, і у разі виявлення пропущених або некоректних значень здійснюється повторний запит до серверу, що забезпечує надійність роботи системи. Алгоритм обчислення середніх балів передбачає сумування значень оцінок для кожного учня та визначення середнього показника із врахуванням відсутніх даних. Подальше формування рейтингу здійснюється на основі обчислених середніх балів та активності учнів у виставках або конкурсах, що дозволяє отримати комплексну оцінку успішності. Для оптимізації часу виконання операцій реалізовано можливість паралельної обробки даних, з наступним злиттям результатів у єдиний потік для підготовки до візуалізації.
	Особлива увага приділяється забезпеченню надійності та коректності обчислень. Алгоритми передбачають контроль за некоректними значеннями, виключення дубльованих записів та узгодження даних з базою серверу. Такий підхід дозволяє зменшити ризик помилок і забезпечити стабільну роботу клієнта навіть за умови неповних або несистематизованих даних.
	3.2. Підготовка даних до візуалізації
	Підготовка даних до відображення у симуляторі є важливим етапом бізнес-логіки, оскільки саме від цього залежить наочність та зручність сприйняття інформації користувачем. Оброблені дані трансформуються у формат, придатний для відображення у таблицях, що включають середні бали, рейтинги, коментарі викладачів та участь у виставках. Кожна таблиця побудована таким чином, щоб користувач міг швидко порівняти результати учнів та оцінити їх активність у творчих заходах. Крім того, до даних додаються графічні позначки для візуального відображення участі у виставках або активності учнів, що забезпечує швидке сприйняття інформації без потреби аналізу великих обсягів текстових даних.
	На етапі підготовки також реалізується сортування та фільтрація даних за різними критеріями, що дозволяє користувачу відображати тільки релевантну інформацію. Важливим аспектом є забезпечення цілісності та послідовності даних при підготовці до відображення, що гарантує узгодженість інформації та відсутність логічних помилок у таблицях та графічних елементах.
	3.3. Обробка взаємодії з користувачем
	Інтерактивні можливості IoT-клієнта визначаються логікою обробки дій користувача, які включають налаштування параметрів відображення, вибір типів даних та інтервалів оновлення інформації. Система передбачає розділення на автоматичні дії та інтерактивні, які виконуються у відповідь на дії користувача. Автоматичні дії включають отримання та обробку даних із серверу, обчислення середніх балів та формування рейтингів, тоді як інтерактивні дії дозволяють користувачу змінювати параметри відображення, налаштовувати формат таблиць та графічних елементів.
	Бізнес-логіка забезпечує коректну синхронізацію між автоматичними процесами та діями користувача. Наприклад, під час зміни параметрів відображення система оновлює дані на екрані без переривання основної обробки, що дозволяє підтримувати постійну актуальність інформації та гнучкість у використанні симулятора. Такий підхід сприяє високому рівню інтерактивності та підвищує ефективність роботи користувача з IoT-клієнтом.
	3.4. Забезпечення надійності та цілісності даних
	Для підтримання стабільності роботи IoT-клієнта розроблено механізми контролю цілісності та достовірності даних. До них належить перевірка отриманих значень на коректність, контроль дублікатів, а також логіка повторних запитів до серверу у випадку неповних або некоректних даних. Обробка даних здійснюється з можливістю паралельного виконання операцій, а результати зливаються у послідовний потік для підготовки до візуалізації.
	Застосування таких механізмів дозволяє забезпечити точність і надійність інформації, зменшити ризик логічних помилок та гарантувати коректне відображення даних у симуляторі. Вони також полегшують подальше масштабування системи, інтеграцію додаткових модулів або роботи з фізичними IoT-пристроями без необхідності змінювати алгоритми обробки.
	Розробка бізнес-логіки IoT-клієнта системи ArtProgress забезпечує комплексну організацію обробки даних та взаємодії з користувачем. Алгоритми обробки, підготовка даних до відображення, інтерактивні функції та механізми контролю достовірності формують основу функціонування програмного симулятора. Ретельно спроектована бізнес-логіка дозволяє ефективно реалізувати наступні етапи проєкту, зокрема програмну реалізацію, налаштування інтерфейсу та тестування, забезпечуючи високий рівень надійності та точності відображення даних. Поєднання алгоритмічної обробки та інтерактивних можливостей користувача забезпечує наочне та системне представлення функціональності IoT-клієнта, що є критично важливим для подальшого впровадження та масштабування системи.

Розділ 4. Моделювання внутрішніх процесів IoT-клієнта
	Розвиток бізнес-логіки IoT-клієнта створює основу для формалізації внутрішніх процесів системи, що забезпечує коректну обробку даних та підготовку інформації до відображення. Після визначення алгоритмів обчислення середніх оцінок, формування рейтингів та підготовки даних до візуалізації виникає потреба у системному моделюванні послідовності дій клієнта. Таке моделювання дозволяє наочно відобразити взаємодію компонентів системи, послідовність виконання операцій, а також забезпечує прогнозовану поведінку програми під час різних сценаріїв використання. Розглядання внутрішніх процесів є необхідним для підготовки до подальшої програмної реалізації, тестування та налаштування інтерфейсу користувача.


	4.1 Організація процесів отримання та обробки даних
	Отримання даних є первинним етапом функціонування IoT-клієнта. Після запуску симулятора система автоматично надсилає запит до серверної частини, що забезпечує актуальність інформації. У разі некоректного отримання даних відбувається повторний запит, що гарантує безперервність процесу та уникнення помилок у відображенні. Після успішного отримання інформації дані проходять обробку, яка включає обчислення середніх оцінок, формування рейтингів учнів та аналіз участі у виставках і творчих заходах. Паралельна обробка різних елементів інформації дозволяє оптимізувати час виконання операцій та підготувати дані до відображення у форматі, зручному для користувача.
	Важливо відзначити, що процеси отримання та обробки даних взаємопов’язані. Будь-яка затримка або помилка на етапі отримання даних може вплинути на подальші обчислення, а коректна обробка забезпечує правильну підготовку інформації для відображення. Така організація роботи підвищує надійність системи та дозволяє уникнути втрати інформації, забезпечуючи її своєчасне оновлення.
	4.2 Взаємодія автоматичних і користувацьких дій
	Моделювання внутрішніх процесів IoT-клієнта передбачає чітке розмежування між автоматичними операціями системи та діями користувача. Автоматичні дії включають запит до серверу, перевірку коректності отриманих даних, обробку інформації, обчислення середніх балів та формування рейтингів. Користувач здійснює взаємодію із симулятором під час перегляду результатів, вибору типів даних для відображення, встановлення інтервалів оновлення та налаштування формату подання інформації. Така організація дій забезпечує гнучкість системи, дозволяє адаптувати інтерфейс під потреби користувача та підтримує надійність процесів обробки даних.
	Розподіл процесів на автоматичні та користувацькі забезпечує також більш ефективне тестування. Автоматичні операції можуть бути перевірені у симуляторі без участі користувача, що дозволяє швидко виявляти помилки в алгоритмах обробки інформації. Користувацькі дії моделюються окремо, що дозволяє оцінити зручність інтерфейсу та ефективність взаємодії з програмою.
	4.3 Послідовність обробки даних та підготовка до візуалізації
	Процес обробки даних починається з отримання структурованої інформації з сервера у форматі JSON, після чого здійснюється її перевірка на повноту та коректність. Наступним етапом є обчислення середніх балів учнів, формування рейтингів та визначення активності у виставках та конкурсах. Результати обчислень агрегуються в єдиний потік, що забезпечує послідовність і правильність відображення даних на екрані симулятора. Візуалізація реалізується переважно у табличній формі, доповненій графічними елементами, що полегшують сприйняття інформації та дозволяють швидко оцінити успішність учнів.
	Кожен етап обробки даних взаємопов’язаний із попереднім та наступним, що дозволяє підтримувати узгодженість інформації на всіх етапах і підвищує надійність роботи IoT-клієнта. Використання моделювання для визначення цих послідовностей сприяє точному відтворенню бізнес-логіки у програмній реалізації.
	4.4 Використання моделювання для тестування та подальшої реалізації
	Моделювання внутрішніх процесів дозволяє заздалегідь виявляти потенційні проблеми у взаємодії компонентів та алгоритмах обробки даних. Це підвищує ефективність тестування і знижує ризики помилок при програмній реалізації. Крім того, на основі UML-діаграм діяльності можна сформувати чіткі технічні вимоги для програмного прототипу та визначити сценарії використання, що забезпечує правильне налаштування інтерфейсу користувача та ефективну демонстрацію функціоналу системи.
	Моделювання внутрішніх процесів IoT-клієнта дозволяє отримати цілісне уявлення про логіку роботи системи, послідовність обробки даних та взаємодію користувачів із системою. Інтеграція автоматичних і користувацьких операцій, деталізація обробки даних та підготовка до візуалізації створюють надійну основу для програмної реалізації, тестування та налаштування інтерфейсу. Такий системний підхід забезпечує гнучкість, масштабованість і надійність IoT-клієнта, а також сприяє ефективній інтеграції подальших модулів і розширень системи.

Розділ 5. Функції налаштування IoT-клієнта
	У цьому розділі наведено системний опис функціональних можливостей конфігурації IoT-клієнта, що забезпечують адаптивність, зручність використання та коректну інтеграцію програмного модуля з серверною частиною системи. Після визначення бізнес-логіки обробки даних та принципів інформаційної взаємодії, проведених у попередньому розділі, постає необхідність формування механізмів, які дозволяють користувачеві впливати на режим роботи клієнта, обсяг видимих даних, методи їх подання та частоту оновлення. Саме опис цих функцій і становить зміст даного розділу. Особливу увагу зосереджено на інженерних підходах до організації параметрів конфігурації, що забезпечують стабільність роботи застосунку, прозорість взаємодії з сервером та передбачуваність поведінки програмних компонент.
	5.1. Параметри вибору даних для відображення
	Однією з ключових функцій IoT-клієнта є можливість визначення користувачем того, які саме дані необхідно відображати під час роботи застосунку. Це пов’язано з тим, що система обробляє кілька типів інформації — оцінки, коментарі, дані про участь у виставках та інші показники, що надходять із серверної частини. Різні категорії користувачів можуть мати різні інформаційні потреби, тому налаштування вибору даних забезпечує гнучкість та адресність подання результатів.
	З інженерної точки зору така функція потребує впорядкованої структури внутрішніх параметрів, які визначають режими відображення. Клієнт має зберігати інформацію про обрані значення та коректно інтегрувати їх у процес побудови інтерфейсу. Внутрішній механізм повинен гарантувати, що зміна цих параметрів не призводить до порушення логіки обробки інформації або до конфліктів із сервісними запитами. Таким чином, можливість вибору конкретних типів даних стає важливою частиною адаптивної логіки роботи клієнта і визначає індивідуальний профіль представлення інформації для кожного користувача.
	5.2. Налаштування інтервалів оновлення інформації
	Інтервал оновлення є фундаментальним параметром, що визначає періодичність отримання даних із сервера. Він має безпосередній вплив на навантаження на мережеві ресурси, швидкість реакції клієнта на зміни та загальну стабільність роботи системи. Надмірно часті запити можуть створити зайве навантаження на канал зв’язку та підвищити ризик втрат пакетів, тоді як надто великі інтервали можуть призвести до втрати актуальності інформації.
	Оскільки IoT-клієнт працює з динамічною інформацією (зміна балів, додавання нових коментарів, оновлення рейтингу), важливо надати користувачеві можливість самостійно визначити прийнятний режим оновлення даних. З технічної точки зору це вимагає впровадження окремого модуля керування таймерами, який забезпечує стабільний запуск оновлення згідно з обраним значенням. Важливо також гарантувати, що зміна інтервалу не порушує синхронізацію з іншими процесами клієнта, зокрема з обробкою та візуалізацією інформації. Описаний механізм створює умови для збалансованого використання системи та підвищує її ефективність у різних сценаріях застосування.
	5.3. Налаштування формату відображення даних
	Ще однією важливою функцією налаштування є вибір формату, у якому інформація подається користувачеві. У межах IoT-клієнта дані можуть відображатися у вигляді текстових значень, графічних елементів, рейтингових індикаторів, спрощених або розгорнутих таблиць. Кожен формат відповідає певному набору задач: графічні елементи забезпечують швидке сприйняття інформації, тоді як детальні таблиці дозволяють виконати глибший аналіз.
	Функція зміни формату відображення передбачає необхідність узгодження між інтерфейсним модулем, логікою відображення та структурою серверних даних. Клієнт повинен коректно трансформувати отримані значення відповідно до обраного формату, зберігаючи цілісність інформації та забезпечуючи однакову точність незалежно від варіанта подання. Додатковою вимогою є підтримка стабільності роботи при перемиканні між форматами, що унеможливлює помилки типу несумісності або відсутності необхідних полів даних. Таким чином, налаштування формату є не лише елементом зручності, а й частиною архітектурної гнучкості IoT-клієнта.
	5.4. Інтеграція налаштувань у бізнес-логіку IoT-клієнта
Усі описані функції конфігурації повинні бути інтегровані в бізнес-логіку клієнта таким чином, щоб вони безпосередньо впливали на алгоритми отримання, обробки та подання інформації. Зміна будь-якого параметра має коректно змінювати поведінку системи, не порушуючи цілісності даних і не створюючи колізій у процесах. Важливим є також забезпечення зворотної сумісності налаштувань, що дає змогу клієнту стабільно працювати навіть у разі неповних даних або помилок під час отримання відповіді від сервера.
	З технічного погляду це потребує чітко визначених внутрішніх структур, відповідальних за зберігання налаштувань, а також механізмів, які забезпечують їх застосування у відповідних модулях системи. Взаємодія між компонентами має бути організована так, щоб інформація про обрані параметри була доступною у всіх критичних точках логічних переходів — від отримання первинних даних до формування вихідного інтерфейсу. Саме така інтеграція є передумовою стабільної роботи клієнта та гарантує узгодженість його поведінки відповідно до вибраних користувачем режимів.

Розділ 6. Реалізація IoT клієнта «Art Progress»
	6.1. Вибір архітектури та інтерфейсу
	На етапі розробки клієнтського застосунку було прийнято рішення реалізувати його у вигляді консольного додатку на платформі .NET 8.0. Такий вибір зумовлений потребою швидкої розробки прототипу, перевірки бізнес-логіки та взаємодії з сервером без додаткових графічних компонентів. Консольна версія забезпечує прозорість роботи методів, спрощує тестування HTTP-запитів та обробку даних.
	Консольне середовище дозволяє зосередитися на основній функціональності, реалізувати асинхронну взаємодію з REST API та створити універсальні методи для отримання і додавання даних про батьків, викладачів, дисципліни та оцінки. Це забезпечує чітку роздільність бізнес-логіки та інтерфейсу, що полегшує подальше масштабування та перетворення на графічний додаток (Windows Forms або WPF) без зміни основної логіки взаємодії із сервером.
	Такий підхід також дозволяє відразу застосовувати перевірку помилок і контроль стану відповіді сервера, що підвищує надійність та стійкість системи. Консольний прототип є зручним для демонстрації роботи, пояснення алгоритмів та логіки обробки предметної області.
	У реальному сценарії розроблений IoT клієнт може стати основою для організації електронної взаємодії між адміністрацією навчального закладу, викладачами, учнями та їхніми батьками. Завдяки централізованій бізнес-логіці, яка відокремлена від інтерфейсу користувача, програма забезпечує швидкий доступ до даних, їх актуалізацію та контроль за навчальним процесом.
	На практиці, такий додаток може бути інтегрований у комп’ютери в адміністративних кабінетах, інтерактивні панелі у класах або спеціальні робочі станції викладачів. Наприклад, адміністратори зможуть вводити та оновлювати інформацію про учнів, реєструвати їх відвідуваність, додавати або редагувати оцінки, створювати сповіщення для окремих учнів або груп. Викладачі отримують швидкий та структурований доступ до даних про учнів, їхні оцінки, дисципліни та сповіщення, що дозволяє планувати навчальний процес та реагувати на зміни у розкладі або поведінці учнів.
	Додатково, реалізація асинхронних методів у клієнті забезпечує миттєве оновлення інформації на робочих станціях без блокування інших процесів, що особливо важливо для середовищ із великою кількістю користувачів. Інформаційні блоки, такі як оцінки, сповіщення або дані про викладачів, можуть бути виведені у вигляді табличних віджетів, списків або інтерактивних карток, що дозволяє користувачу зручно переглядати та редагувати дані без необхідності глибоких знань з комп’ютерних технологій.
	Крім того, архітектура програми дозволяє легко адаптувати консольні методи до графічних інтерфейсів Windows Forms або веб-додатків, що відкриває можливість використання рішення як у кабінетах адміністрації, так і на персональних пристроях викладачів та батьків. Така інтеграція створює єдину цифрову екосистему навчального закладу, де інформація про учнів і навчальний процес завжди доступна у актуальному вигляді, а обмін повідомленнями між учасниками відбувається оперативно та структуровано.
	6.2. Реалізація бізнес-логіки та методів обробки даних
	Бізнес-логіка клієнта реалізована через асинхронні методи, які виконують операції з отримання та додавання інформації через REST API. Для кожного типу даних передбачено окремі методи:
	- отримання списку батьків, викладачів, оцінок, дисциплін і сповіщень;
	- додавання нового батька, викладача або сповіщення;
	- робота з IoT-пристроями: отримання стану сенсорів, надсилання даних та моніторинг у реальному часі. 
	Методи для отримання даних (ShowParents, ShowGrades, ShowTeachers, ShowTeacherDisciplines, ShowNotifications) застосовують GetFromJsonAsync, що забезпечує неблокуюче очікування відповіді сервера та дозволяє продовжувати виконання інших дій, не зупиняючи додаток. Методи додавання (AddParent, AddTeacher, AddNotification) використовують PostAsJsonAsync, що дозволяє надійно передавати дані у форматі JSON.
	Для всіх методів передбачено обробку винятків та перевірку коду відповіді сервера, що гарантує безпечне виконання програми та інформує користувача про помилки. Така організація забезпечує стабільну роботу та коректну обробку предметної інформації. Детальні фрагменти реалізації методів наведені в Додатку А (A.1–A.9).
	6.3. Налаштування IoT клієнта
	Центральним елементом налаштування клієнта є створення екземпляру HttpClient із встановленою базовою адресою сервера (BaseAddress). Це дозволяє централізовано керувати всіма HTTP-запитами та легко змінювати серверне середовище при потребі.
	Всі методи бізнес-логіки отримують доступ до цього клієнта, що забезпечує повторне використання HTTP-з’єднання і оптимізує ресурси програми. Конфігурація клієнта продумана так, щоб мінімізувати залежність коду від конкретного середовища та дозволяти майбутнє масштабування у графічний додаток або інтеграцію з більш складними IoT-системами.
	6.3.1. Перевірка та налаштування підключення IoT-клієнта
	Для забезпечення гнучкості підключення до серверної частини застосунку розроблено можливість динамічного налаштування адреси сервера. Під час запуску користувач може ввести власну адресу сервера або залишити поле порожнім, у такому випадку буде використано адресу за замовчуванням, що вказана як localhost. Це дозволяє легко адаптувати клієнт під різні серверні середовища без необхідності змінювати код і забезпечує універсальність застосунку як для тестових, так і для реальних умов експлуатації.
	Всі методи взаємодії з сервером, включаючи функції додавання батьків, викладачів, сповіщень та перегляду даних, використовують централізований екземпляр HttpClient з встановленою базовою адресою. Завдяки цьому забезпечується повторне використання HTTP-з’єднання, оптимізація ресурсів та єдина точка контролю всіх запитів. Така організація коду дозволяє уникнути дублювання логіки перевірки підключення в кожному методі і спрощує підтримку програми.
	Під час виконання запитів відбувається перевірка доступності сервера. Якщо сервер відповідає, дані успішно надсилаються або отримуються, і результати відображаються у консольному інтерфейсі користувача. У разі недоступності сервера генерується виняток, який перехоплюється, а користувач отримує повідомлення про помилку. Такий підхід запобігає аварійному завершенню роботи програми і дозволяє вчасно реагувати на проблеми з підключенням або неправильне налаштування адреси.
	Завдяки реалізації механізму налаштування та перевірки підключення IoT-клієнт демонструє високу надійність і стійкість до помилок. Він готовий до використання в різних сценаріях, включаючи демонстраційні прототипи та реальні умови роботи навчального закладу. Централізоване налаштування забезпечує швидкий доступ до даних, стабільну роботу асинхронних методів і гнучке масштабування системи під нові потреби або інтеграцію з графічними та веб-додатками.
	6.4. Особливості реалізації та адаптації під реальні умови
	Консольний клієнт виконує базову функцію прототипу IoT-застосунку: отримання, відображення та додавання даних. Цей підхід дозволяє швидко демонструвати логіку роботи системи та тестувати серверні запити.
	У реальних умовах консольні методи можна адаптувати до графічного інтерфейсу, де введення даних користувачем та відображення інформації буде здійснюватися через форми та таблиці. Наприклад, методи AddParent і AddTeacher можна інтегрувати у форми з текстовими полями та кнопками, а результати методів ShowParents та ShowGrades – у DataGridView. При цьому вся бізнес-логіка, обробка винятків та перевірка відповіді сервера залишаються без змін, що спрощує підтримку та розвиток системи.
	Також застосунок легко розширювати: можна додавати нові методи для роботи з IoT-пристроями, сенсорами чи іншими джерелами даних, використовуючи ту ж архітектуру асинхронних методів і централізований HTTP-клієнт.


	6.5. Посилання на фрагменти коду
	Для зручності демонстрації реалізації наведено фрагменти коду в Додатку А:
	A.1 – Показ батьків (ShowParents): метод отримує список батьків із сервера і виводить їх на екран. Консольний інтерфейс дозволяє швидко перевіряти правильність отриманих даних та структуру JSON.
	A.2 – Додавання нового батька (AddParent): реалізує введення користувачем імені та контактної інформації, перевірку даних і надсилання на сервер. Асинхронна обробка забезпечує відсутність блокування програми під час очікування відповіді сервера.
	A.3 – Показ оцінок (ShowGrades): метод демонструє отримання та відображення структурованих даних про оцінки учнів. Це дозволяє проводити контроль і аналіз навчальної діяльності.
	A.4 – Налаштування HTTP-клієнта: централізоване налаштування базової адреси сервера і повторне використання клієнта для всіх запитів. Забезпечує ефективне використання ресурсів.
	A.5 – Показ викладачів (ShowTeachers): метод отримує список викладачів та їх контактну інформацію. Використовується для управління кадровими ресурсами та контролю дисциплін.
	A.6 – Додавання викладача (AddTeacher): введення даних викладача користувачем та відправка на сервер. Дозволяє додавати нові записи без втручання у серверну логіку.
A.7 – Показ дисциплін викладачів (ShowTeacherDisciplines): метод відображає відповідність викладачів та дисциплін, що дозволяє аналізувати навантаження та планування навчального процесу.
	A.8 – Показ сповіщень (ShowNotifications): метод отримує всі сповіщення, які стосуються учнів та батьків, та відображає їх на екрані.
	A.9 – Додавання сповіщення (AddNotification): дозволяє адміністрації або викладачам додавати сповіщення для учнів та батьків, забезпечуючи комунікацію між учасниками освітнього процесу.
	Кожен метод реалізований так, щоб зберігати бізнес-логіку незалежно від інтерфейсу, що дозволяє легко інтегрувати його у графічні додатки, веб-сервіси або інтерактивні панелі для використання у школах.
	A.10 – Бізнес-логіка: обчислення середнього балу студентів (CalculateAverageGrade): метод збирає дані про оцінки учнів і обчислює середній бал для конкретного класу або групи. Це дозволяє швидко отримати узагальнену оцінку успішності.
	A.11 – Бізнес-логіка: підрахунок кількості сповіщень по батьках (CountNotificationsPerParent): метод аналізує всі наявні сповіщення та підраховує їх кількість для кожного батька, що дає змогу контролювати активність комунікації та своєчасно реагувати на повідомлення. 
	A.12 – Перевірка та налаштування підключення IoT-клієнта: цей фрагмент коду демонструє реалізацію механізму динамічного встановлення базової адреси сервера та перевірки його доступності. Користувач може ввести власну адресу або залишити поле порожнім для використання адреси за замовчуванням (localhost). Далі виконується пробне підключення до сервера через запит ping, і у разі успіху користувач отримує підтвердження підключення. У разі недоступності сервера генерується повідомлення про помилку. Такий підхід дозволяє централізовано контролювати всі запити та забезпечує стійкість програми до помилок при взаємодії з сервером. 
	Таким чином, розробка IoT-клієнта «Art Progress» у вигляді консольного додатку дозволила ефективно поєднати перевірку бізнес-логіки та функціональних можливостей з простотою інтерфейсу. Використання асинхронних методів і централізованого HTTP-клієнта забезпечує стабільну роботу, гнучке налаштування та масштабованість системи. Реалізовані методи для роботи з батьками, викладачами, оцінками та сповіщеннями демонструють, як бізнес-логіка відокремлена від інтерфейсу і готова до інтеграції у графічні або веб-додатки, що робить клієнт універсальним інструментом для автоматизації та контролю навчального процесу в освітньому середовищі. 

Розділ 7. Тестування розробленого програмного забезпечення
	Тестування клієнтського застосунку IoT Client Art Progress проводилося з метою перевірки повноцінної роботи реалізованих функцій, стабільності обміну даними з сервером та відповідності очікуваній логіці програмного забезпечення. Основним завданням тестування було впевнитися, що всі передбачені операції, виконуються коректно, забезпечують правильне відображення інформації та не спричиняють помилок при взаємодії з базою даних.
	Процедура тестування включала поетапне виконання всіх функцій системи: від перегляду даних до додавання нових записів, перевірки оновлених списків та перегляду системних сповіщень. Кожен етап містив контроль коректності введених даних, валідацію виводу, перевірку унікальності записів та відповідність отриманих даних очікуваному результату.
	7.1 Перегляд усіх батьків
	Першим етапом тестування було перевірено функцію виведення повного списку батьків. Основна мета — переконатися, що система відображає всі наявні записи з коректними полями: ID, ім’я та контактна інформація.
	Тестова операція полягала у виборі команди «Показати всіх батьків». У результаті система вивела список, який відповідав даним бази.










Рис. 7.1 — Результат виконання команди «Показати всіх батьків».

	7.2 Додавання нового батька
	На цьому етапі перевірялася взаємодія клієнтського застосунку з API при надсиланні POST-запиту для створення нового запису. Користувач вводив ім’я та контактні дані нового батька, після чого система повертала повідомлення про успішне додавання.












                                            
Рис. 7.2 — Виконання команди «Додати нового батька».

	7.3 Перевірка оновленого переліку батьків
	Після додавання нового батька здійснювалася повторна команда «Показати всіх батьків». Мета — перевірити, чи новий запис з’явився у загальному списку та отримав унікальний ID. Новий батько доданий у список із коректним ID та контактними даними.








Рис. 7.3 — Оновлений список батьків після додавання нового запису
	7.4 Перегляд усіх оцінок
	Цей етап тестування передбачав перевірку коректності виведення академічної інформації: значення StudentID, TeacherID, DisciplineID та оцінки. Система демонструє повний список оцінок студентів, що підтверджує правильність структури та зв’язків між сутностями.













Рис. 7.4 — Результат виконання команди «Показати всі оцінки».

    7.5  Перегляд викладачів, додавання нового та повторна перевірка списку                          
      
 


Рис. 7.5 — Початковий список викладачів.





Рис. 7.6 — Виконання команди «Додати нового викладача».


Рис. 7.7 — Оновлений перелік викладачів після додавання нового запису.
	7.6 Перегляд дисциплін викладачів
	На цьому етапі тестування перевірено правильність зв’язку між викладачами та дисциплінами, а також коректність відображення даних у списку.









Рис. 7.8 — Результат виконання команди «Показати всі дисципліни викладачів».

	7.7 Перегляд усіх сповіщень
	Завершальний етап тестування стосувався перевірки отримання повного переліку сповіщень, що надсилаються системою. Оцінювалася коректність структури: ID, текст повідомлення, StudentID, ParentID.  Всі повідомлення системи відображаються правильно та відповідають даним у серверній частині.



Рис. 7.9 — Список усіх сповіщень
	Проведене тестування показало, що всі функції клієнтського застосунку IoT Client Art Progress працюють коректно, інформація з бази даних відображається повністю та зберігає цілісність. Додані записи успішно інтегруються у загальні списки, а зв’язки між сутностями (батьки, викладачі, дисципліни, оцінки, сповіщення) відображаються правильно.
	7.8 Бізнес-логіка: обчислення середнього балу студентів 
	Тестування цього пункту включало вибір команди «Бізнес-логіка: середній бал студентів». Система збирає усі оцінки студентів та обчислює середній бал для групи.








Рис. 7.10 — Вивід середнього балу студентів 

	7.9 Бізнес-логіка: підрахунок кількості сповіщень по батьках 
	Перевірка цього пункту проводилася шляхом вибору команди «Бізнес-логіка: кількість сповіщень по батьках». Система групує всі сповіщення за ParentID та виводить кількість для кожного батька.









Рис. 7.11 — Підрахунок кількості сповіщень по батьках
	Проведене тестування показало, що всі функції клієнтського застосунку IoT Client Art Progress працюють коректно, інформація з бази даних відображається повністю та зберігає цілісність. Додані записи успішно інтегруються у загальні списки, а зв’язки між сутностями (батьки, викладачі, дисципліни, оцінки, сповіщення) відображаються правильно.
Результати тестування підтверджують стабільність, надійність та готовність застосунку до експлуатації. Всі операції виконуються у передбаченому порядку та забезпечують коректну взаємодію з серверною частиною системи.

Висновки 
	У процесі виконання лабораторної роботи було проведено повний цикл розробки програмного модуля IoT-клієнта «Art Progress», призначеного для збору, обробки та візуалізації даних про успішність учнів художніх навчальних закладів. Основною метою роботи було дослідження методів інтеграції програмних компонентів, обробки структурованих даних та реалізації стабільного механізму взаємодії клієнтської частини із серверними сервісами.
	Для тестування і налагодження алгоритмів була використана модель симулятора IoT-пристрою, що дозволяє відтворювати реальні умови збору даних без залучення фізичного обладнання. Це забезпечило можливість перевірки коректності алгоритмів обробки та валідації інформації на ранніх етапах розробки.
	Програмна реалізація передбачає використання методів структурованої обробки даних, включаючи сортування, фільтрацію, обчислення рейтингів та агрегування інформації. Впроваджені алгоритми забезпечують високий рівень надійності та точності результатів, що критично для навчальних інформаційних систем.
	Взаємодія клієнтської частини із сервером здійснюється через REST API, що дозволяє ефективно організувати обмін даними, синхронізувати запити користувача та контролювати достовірність отриманої інформації. Запроваджені механізми обробки помилок, перевірки коректності даних та логування дій забезпечують стабільну роботу системи та підвищують її надійність.
	Розроблена система також включає компоненти візуалізації даних, що дозволяють користувачам отримувати інформацію у наочному та доступному форматі. Це включає формування таблиць, графіків та інтерактивних елементів, що забезпечує швидке сприйняття результатів та підтримку прийняття рішень.
	Отримані результати демонструють системний підхід до проектування програмних модулів: поєднання моделювання, обробки даних, інтерактивних функцій та стабільної взаємодії з сервером забезпечує надійність, ефективність та гнучкість системи. Виконана робота створює основу для подальшої інтеграції з реальними IoT-пристроями та розширення функціоналу навчальної інформаційної платформи.
	Таким чином, лабораторна робота підтвердила ефективність обраних методів обробки даних та інженерних рішень, що забезпечують реалізацію сучасних інформаційних систем для навчальних закладів із високими вимогами до надійності та точності представленої інформації.






ДОДАТОК А -  Приклади програмного коду IoT клієнта
A.1 – Показ батьків (ShowParents)

1  static async Task ShowParents(HttpClient client)
2  {
3      try
4      {
5          var parents = await client.GetFromJsonAsync<List<Parent>>("parents");
6          Console.WriteLine("Список батьків:");
7          foreach (var p in parents)
8          {
9              Console.WriteLine($"ID: {p.ParentID}, Ім'я: {p.Name}, Контакт: {p.ContactInfo}");
10         }
11     }
12     catch (Exception ex)
13     {
14         Console.WriteLine("Помилка при отриманні батьків: " + ex.Message);
15     }
16 }



A.2 – Додавання нового батька (AddParent)

1  static async Task AddParent(HttpClient client)
2  {
3      Console.Write("Введіть ім'я батька: ");
4      string name = Console.ReadLine();
5      Console.Write("Введіть контактну інформацію: ");
6      string contact = Console.ReadLine();
7
8      var newParent = new ParentDto
9      {
10         Name = name,
11         ContactInfo = contact
12     };
13
14     try
15     {
16         var response = await client.PostAsJsonAsync("parents", newParent);
17         if (response.IsSuccessStatusCode)
18             Console.WriteLine("Батька успішно додано!");
19         else
20             Console.WriteLine("Помилка при додаванні батька: " + response.StatusCode);
21     }
22     catch (Exception ex)
23     {
24         Console.WriteLine("Помилка при додаванні батька: " + ex.Message);
25     }
26 }

A.3 – Показ оцінок (ShowGrades)

1  static async Task ShowGrades(HttpClient client)
2  {
3      try
4      {
5          var grades = await client.GetFromJsonAsync<List<Grade>>("grades");
6          Console.WriteLine("Список оцінок:");
7          foreach (var g in grades)
8          {
9              Console.WriteLine($"ID: {g.GradeID}, StudentID: {g.StudentID}, TeacherID: {g.TeacherID}, DisciplineID: {g.DisciplineID}, Оцінка: {g.Value}");
10         }
11     }
12     catch (Exception ex)
13     {
14         Console.WriteLine("Помилка при отриманні оцінок: " + ex.Message);
15     }
16 }

A.4 – Налаштування HTTP-клієнта

1  var client = new HttpClient();
2  client.BaseAddress = new Uri("https://localhost:7033/api/"); // порт вашого бекенду
3
4  // Асинхронне отримання даних
5  var parents = await client.GetFromJsonAsync<List<Parent>>("parents");
6
7  // Асинхронне надсилання даних
8  var response = await client.PostAsJsonAsync("parents", new ParentDto { Name = "Ім'я", ContactInfo = "Контакт" });

A.5 – Показ викладачів (ShowTeachers)

1  static async Task ShowTeachers(HttpClient client)
2  {
3      try
4      {
5          var teachers = await client.GetFromJsonAsync<List<Teacher>>("teachers");
6          Console.WriteLine("Список викладачів:");
7          foreach (var t in teachers)
8          {
9              Console.WriteLine($"ID: {t.TeacherID}, Ім'я: {t.Name}, Посада: {t.Position}, Контакт: {t.ContactInfo}");
10         }
11     }
12     catch (Exception ex)
13     {
14         Console.WriteLine("Помилка при отриманні викладачів: " + ex.Message);
15     }
16 }

A.6 – Додавання викладача (AddTeacher)

1  static async Task AddTeacher(HttpClient client)
2  {
3      Console.Write("Введіть ім'я викладача: ");
4      string name = Console.ReadLine();
5      Console.Write("Введіть посаду: ");
6      string position = Console.ReadLine();
7      Console.Write("Введіть контактну інформацію: ");
8      string contact = Console.ReadLine();
9
10     var newTeacher = new TeacherDto
11     {
12         Name = name,
13         Position = position,
14         ContactInfo = contact
15     };
16
17     try
18     {
19         var response = await client.PostAsJsonAsync("teachers", newTeacher);
20         if (response.IsSuccessStatusCode)
21             Console.WriteLine("Викладача успішно додано!");
22         else
23             Console.WriteLine("Помилка при додаванні викладача: " + response.StatusCode);
24     }
25     catch (Exception ex)
26     {
27         Console.WriteLine("Помилка при додаванні викладача: " + ex.Message);
28     }
29 }









A.7 – Показ дисциплін викладачів (ShowTeacherDisciplines)

1  static async Task ShowTeacherDisciplines(HttpClient client)
2  {
3      try
4      {
5          var tds = await client.GetFromJsonAsync<List<TeacherDiscipline>>("TeacherDisciplines");
6          Console.WriteLine("Список дисциплін викладачів:");
7          foreach (var td in tds)
8          {
9              Console.WriteLine($"TeacherID: {td.TeacherID}, DisciplineID: {td.DisciplineID}");
10         }
11     }
12     catch (Exception ex)
13     {
14         Console.WriteLine("Помилка при отриманні дисциплін: " + ex.Message);
15     }
16 }


A.8 – Показ сповіщень (ShowNotifications)

1  static async Task ShowNotifications(HttpClient client)
2  {
3      try
4      {
5          var notifications = await client.GetFromJsonAsync<List<Notification>>("notifications");
6          Console.WriteLine("Список сповіщень:");
7          foreach (var n in notifications)
8          {
9              Console.WriteLine($"ID: {n.NotificationID}, Текст: {n.Text}, StudentID: {n.StudentID}, ParentID: {n.ParentID}");
10         }
11     }
12     catch (Exception ex)
13     {
14         Console.WriteLine("Помилка при отриманні сповіщень: " + ex.Message);
15     }
16 }

A.9 – Додавання сповіщення (AddNotification)

1  static async Task AddNotification(HttpClient client)
2  {
3      Console.Write("Введіть текст сповіщення: ");
4      string text = Console.ReadLine();
5      Console.Write("Введіть StudentID (якщо є, інакше 0): ");
6      int studentId = int.Parse(Console.ReadLine() ?? "0");
7      Console.Write("Введіть ParentID (якщо є, інакше 0): ");
8      int parentId = int.Parse(Console.ReadLine() ?? "0");
9
10     var newNotification = new NotificationDto
11     {
12         Text = text,
13         StudentID = studentId == 0 ? (int?)null : studentId,
14         ParentID = parentId == 0 ? (int?)null : parentId
15     };
16
17     try
18     {
19         var response = await client.PostAsJsonAsync("notifications", newNotification);
20         if (response.IsSuccessStatusCode)
21             Console.WriteLine("Сповіщення успішно додано!");
22         else
23             Console.WriteLine("Помилка при додаванні сповіщення: " + response.StatusCode);
24     }
25     catch (Exception ex)
26     {
27         Console.WriteLine("Помилка при додаванні сповіщення: " + ex.Message);
28     }
29 }

A.10 – Бізнес-логіка: обчислення середнього балу студентів 

1   static async Task ShowAverageGrades(HttpClient client)
2   {
3       try
4       {
5           var grades = await client.GetFromJsonAsync<List<Grade>>("grades");
6           if (grades.Count == 0) 
7           { 
8               Console.WriteLine("Оцінок немає"); 
9               return; 
10          }
11          double avg = grades.Average(g => g.Value);
12          Console.WriteLine($"Середній бал студентів: {avg:F2}");
13      }
14      catch (Exception ex)
15      {
16          Console.WriteLine("Помилка при обчисленні середнього балу: " + ex.Message);
17      }
18  }

A.11 – Бізнес-логіка: підрахунок кількості сповіщень по батьках 

1   static async Task ShowNotificationsCountByParent(HttpClient client)
2   {
3       try
4       {
5           var notifications = await client.GetFromJsonAsync<List<Notification>>("notifications");
6           var grouped = notifications.GroupBy(n => n.ParentID);
7           foreach (var group in grouped)
8           {
9               Console.WriteLine($"ParentID: {group.Key}, кількість сповіщень: {group.Count()}");
10          }
11      }
12      catch (Exception ex)
13      {
14          Console.WriteLine("Помилка при підрахунку сповіщень: " + ex.Message);
15      }
16  }

A.12 – Налаштування базової адреси сервера

1 Console.Write("Введіть адресу сервера (або Enter для localhost): ");
2 string? serverAddress = Console.ReadLine();
3 if (string.IsNullOrWhiteSpace(serverAddress))
4 {
5     client.BaseAddress = new 
6 Uri("https://localhost:7033/api/");
7 }
8 else
9 {
10     client.BaseAddress = new Uri(serverAddress);
11 }
12 
13 try
14 {
15     var response = await client.GetAsync("ping");
16     response.EnsureSuccessStatusCode();
17     Console.WriteLine("Підключення до сервера встановлено успішно.");
18 }
19 catch (HttpRequestException)
20 {
21     Console.WriteLine("Помилка підключення до сервера. Перевірте адресу або доступність сервера.");
22 }
