 Міністерство освіти і науки України
 Харківський національний університет радіоелектроніки 
Кафедра програмної інженерії 









Лабораторна робота №5
 з дисципліни: «Аналіз та рефакторінг коду»
 на тему: «РОЗГОРТАННЯ ПРОГРАМНОЇ СИСТЕМИ ТА ДЕМОНСТРАЦІЯ ЇЇ РОБОТИ»








Виконала: ст. гр. ПЗПІ-23-9
Сеніна Єлизавета Андріївна

Перевірив: Дашенков Дмитро Сергійович





 Харків 2025
	Метою лабораторної роботи є практичне розгортання програмної системи ArtProgress, перевірка її працездатності та демонстрація функціональності, визначеної у документі Vision & Scope. Робота спрямована на підтвердження коректності реалізації бізнес-логіки, функцій адміністрування та взаємодії IoT-клієнта із серверною частиною.

	1. Розгортання програмної системи
	На основі побудованої ER-діаграми та фізичної моделі бази даних було здійснено розгортання програмної системи ArtProgress у середовищі Visual Studio 2022 із використанням платформи .NET та системи керування базами даних MySQL. Для цього було клоновано репозиторій із реалізованим кодом, відновлено всі необхідні залежності та налаштовано параметри підключення до бази даних у конфігураційному файлі застосунку. Після виконання міграцій Entity Framework Core у середовищі MySQL Workbench було створено повну структуру бази даних, яка відповідає розробленій моделі та включає всі основні сутності освітнього процесу.
	У результаті було сформовано таблиці Student, Parent, Teacher, Discipline, Grade, Comment, Portfolio, Notification, Admin, ParentStudent, TeacherDiscipline, що відображають ключові об’єкти системи та їхні взаємозв’язки. Після запуску локального сервера перевірено доступність Swagger UI та коректність роутингу ендпоінтів «api/[controller]». Це підтвердило працездатність серверної частини, узгодженість моделей і зв’язків та готовність системи до взаємодії з клієнтськими застосунками.

Рисунок 1.1 — Запуск Swagger UI з переліком контролерів API ArtProgress

Рисунок 1.2 — Запуск Swagger UI з переліком контролерів API ArtProgress













Рисунок 1.2 — Запуск Swagger UI з переліком контролерів API ArtProgress
	2. Перевірка роботи серверної частини через API (Swagger UI)
	Перевірка починалася з отримання списку студентів у форматі JSON. Відповідь сервера демонструвала коректно серіалізовані сутності з полями ідентифікації, імені, групи та контактної інформації. Це підтвердило узгодженість моделій рівня даних та API.




Рисунок 2.1 — Результат запиту GET /api/Students з переліком студентів у JSON 

	На наступному етапі перевірено створення нової оцінки через запит POST /api/Grades. До запиту було передано значення оцінки, дату, ідентифікатори студента, викладача та дисципліни. У відповіді повернувся код 201 Created, а тіло відповіді містило створений запис з призначеним ключем. Це підтверджує правильність роботи сервісу додавання оцінок та узгодженість зовнішніх ключів.

Рисунок 2.2 — Запит POST /api/Grades і відповідь 201 Created із створеним ресурсом 

	Після додавання оцінки було перевірено автоматичну логіку створення повідомлень. За допомогою GET /api/Notifications/student/{id} отримано масив сповіщень для студента, серед яких було повідомлення про щойно додану оцінку. Аналогічно перевірено повідомлення для батьків через GET /api/Notifications/parent/{id}, що підтверджує коректну інтеграцію NotificationService з проміжною таблицею ParentStudent та валідність nullable-зовнішніх ключів у моделі Notification.

Рисунок 2.3 — Повідомлення для студента про нову оцінку у відповіді GET /api/Notifications/student/{id} 


Рисунок 2.4 — Повідомлення для батька у відповіді GET /api/Notifications/parent/{id} 

	Окремо перевірено навігаційні властивості — запит GET /api/Notifications повернув повний об’єкт із включеними сутностями Student та Teacher, що підтвердило правильність конфігурації Include/ThenInclude у серверній логіці та узгодженість моделі даних.

Рисунок 2.5 — Повна відповідь GET /api/Notifications із навігаційними властивостями 

	Було виконано тестове оновлення через PUT /api/Parents/{id}, після чого повторний GET підтвердив наявність змін у відповідних полях запису. Видалення ресурсу перевірено через DELETE /api/Parents/{id} з отриманням відповіді 204 No Content, що засвідчує коректну роботу каскадних обмежень і узгодженість операцій CRUD.
















Рисунок 2.6 — Запит PUT /api/Parents/{id} з оновленням даних 









Рисунок 2.7 — Запит DELETE /api/Parents/{id} з відповіддю 204 No Content 


	3. Демонстрація реалізованої бізнес-логіки
	Реалізована бізнес-логіка системи ArtProgress підтверджується на прикладі сценарію додавання оцінки викладачем та автоматичного інформування зацікавлених сторін. Після виконання запиту на створення оцінки (див. рисунок 2.2) у таблиці Grade формується новий запис, який містить значення оцінки, дату її виставлення та зовнішні ключі на студента, викладача й дисципліну. Одразу після цього система автоматично створює коментар викладача, що дозволяє зберігати пояснення до оцінки без додаткових дій користувача.
	Наступним етапом є виклик механізму сповіщень. Як показано у відповіді на запит GET /api/Notifications/student/{id} (див. рисунок 2.3), студент отримує повідомлення про нову оцінку. Аналогічно, у відповіді GET /api/Notifications/parent/{id} (див. рисунок 2.4) батьки отримують повідомлення про оцінку дитини. Це підтверджує коректну інтеграцію NotificationService з проміжною таблицею ParentStudent, яка реалізує зв’язок «багато-до-багатьох» між студентами та їхніми законними представниками.
	Окремо було перевірено навігаційні властивості, які забезпечують включення пов’язаних сутностей у відповідь API. Як видно з рисунка 2.5, запит GET /api/Notifications повертає повний об’єкт із вкладеними даними студента та викладача. Це демонструє правильність конфігурації методів Include/ThenInclude у бізнес-логіці та підтверджує узгодженість моделі даних.
	Таким чином, бізнес-логіка системи реалізує повний цикл обробки навчальних даних: від створення оцінки до автоматичного формування коментаря та сповіщень для студентів і батьків. Послідовність запитів і відповідей, наведена у рисунках 2.2–2.5, підтверджує прозорість та автоматизованість процесів, а також відповідність реалізації вимогам, визначеним у документі Vision & Scope.

	4. Функції адміністрування серверної частини та бізнес-логіки
	Функції адміністрування у системі ArtProgress реалізовані через окремий контролер AdminController, який забезпечує управління навчальними дисциплінами та отримання узагальненої статистики роботи системи. Це дозволяє адміністрації підтримувати актуальність освітнього процесу та здійснювати моніторинг загального стану бази даних.
	У процесі тестування було перевірено роботу ендпоінта POST /api/Admin/disciplines, який дозволяє додавати нову дисципліну. Запит виконується у форматі JSON, де передається назва дисципліни. У відповіді сервер повертає код 200 OK, що підтверджує успішне створення запису. Такий функціонал забезпечує гнучкість системи та можливість оперативно розширювати перелік навчальних предметів.










Рисунок 4.1 — Демонстрація створення дисципліни через POST /api/Admin/disciplines

	Окрім цього, було протестовано ендпоінт GET /api/Admin/systemstats, який повертає агреговану статистику щодо кількості студентів, викладачів, дисциплін та оцінок, а також середній бал усіх студентів. Ця функція реалізована у сервісі AdminService дозволяє адміністрації отримувати не лише кількісні показники, а й якісний індикатор успішності навчального процесу. Обчислення середнього балу реалізовано у сервісі AdminService за допомогою LINQ-запиту до таблиці оцінок, а результат округлюється до двох знаків після коми для стандартизованого представлення у звітах. Таким чином, адміністратор може швидко оцінити загальний рівень знань студентів та використовувати ці дані для прийняття управлінських рішень.













Рисунок 4.2 — Демонстрація отримання статистики системи через GET /api/Admin/systemstats
	Також у контролері передбачено можливість видалення дисципліни через DELETE /api/Admin/disciplines/{id}, що дозволяє підтримувати актуальність даних та уникати дублювання. Перевірка цього ендпоінта підтвердила коректність каскадних обмежень та узгодженість транзакцій у EF Core.
	Таким чином, функції адміністрування охоплюють додавання та видалення дисциплін, а також отримання системної статистики. Це забезпечує стабільність роботи програмного комплексу, його відповідність вимогам до серверної частини та створює умови для ефективного управління освітнім процесом.

	5. Функції налаштування IoT-клієнта
	IoT-клієнт реалізовано як консольний застосунок на платформі .NET, який взаємодіє з REST API сервера. На етапі запуску клієнт пропонує ввести адресу сервера або використати адресу за замовчуванням (localhost). Після встановлення базової адреси здійснюється перевірка доступності сервера. Далі клієнт виконує асинхронні запити для отримання батьків, оцінок, викладачів, дисциплін та сповіщень, а результати відображаються у консольному інтерфейсі у вигляді таблиць. Окремо реалізовано бізнес-функції клієнта для обчислення середнього балу групи та підрахунку кількості сповіщень для кожного батька. Пояснення щодо архітектури та посилання на код наведено у Додатку А.






Рисунок 5.1 — Головне меню IoT-клієнта з переліком доступних функцій








Рисунок 5.2 — Результат виконання «Показати всіх батьків» у консолі 













Рисунок 5.3 — Результат виконання «Показати всі оцінки» 





Рисунок 5.4 — Результат «Додати нового викладача» з підтвердженням 


Рисунок 5.5 — Результат «Показати всі сповіщення»







Рисунок 5.6 — Бізнес-логіка: обчислення середнього балу студентів









Рисунок 5.7 — Бізнес-логіка: кількість сповіщень по батьках 

6. Взаємодія IoT-клієнта та сервера
Взаємодія побудована на стандартних HTTP-запитах у форматі JSON. Кожна операція клієнта використовує централізований екземпляр HttpClient з базовою адресою, що дозволяє повторно використовувати з’єднання та гарантувати стабільність мережевої взаємодії. Обробка винятків забезпечує коректне інформування користувача у разі недоступності сервера або помилки відповіді. Демонстраційні сценарії — отримання даних, додавання записів, перегляд сповіщень — відпрацьовують без збоїв і узгоджено з логікою серверної частини. Відеодемонстрація містить повний цикл безперервної роботи: введення адреси, успішний «ping», виконання запитів і відображення результатів.











Рисунок 6.1 — Встановлення базової адреси та підтвердження підключення 

Висновки
У ході виконання лабораторної роботи було успішно розгорнуто програмну систему ArtProgress, перевірено її працездатність та підтверджено коректність реалізації бізнес-логіки. Система показала узгодженість моделей даних, стабільність роботи CRUD-операцій та правильність роутингу ендпоінтів. Робота з API через Swagger UI продемонструвала, що всі основні функції серверної частини працюють відповідно до очікуваної поведінки, а взаємодія між сутностями реалізована без помилок.
Особливу увагу було приділено перевірці бізнес-логіки, яка забезпечує автоматичне створення коментарів та сповіщень після додавання оцінки. Це підтвердило, що система здатна не лише зберігати дані, а й виконувати узгоджені дії, які відповідають реальним потребам освітнього процесу. Адміністративні функції також показали свою ефективність: адміністратор може додавати та видаляти дисципліни, а також отримувати системну статистику. Важливим удосконаленням стало розширення статистики якісним показником — середнім балом студентів, що дозволяє оцінювати рівень успішності навчання.
Окремо було перевірено роботу IoT-клієнта, який взаємодіє із сервером через REST API. Клієнт здатний отримувати дані про студентів, викладачів, дисципліни та сповіщення, а також виконувати бізнес-функції, такі як обчислення середнього балу групи чи підрахунок кількості сповіщень для батьків. Це підтвердило можливість інтеграції системи з різними клієнтськими застосунками та її гнучкість у використанні.
Таким чином, реалізована система є працездатною, узгодженою та готовою до практичного застосування. Вона може бути розширена у майбутньому за рахунок додаткових аналітичних функцій, інтеграції з мобільними клієнтами та впровадження графічних інтерфейсів для зручнішого використання. Отримані результати свідчать про те, що ArtProgress має потенціал стати ефективним інструментом для управління освітнім процесом, аналітики та інтеграції сучасних технологій у навчання.








ДОДАТОК А
А.1 — Контролер оцінок (GradesController): методи POST для створення оцінки та GET для перегляду

 1     public async Task<ActionResult<Grade>> PostGrade(GradeDto dto)
 2     {
 3         var grade = await _gradesService.AddGradeAsync(
 4             dto.StudentID,
 5             dto.TeacherID,
 6             dto.DisciplineID,
 7             dto.Value,
 8             null
 9         );
10
11         return CreatedAtAction(nameof(GetGrade), new { id = grade.GradeID }, grade);
12     }
13
14     //  PUT: оновити оцінку
15     [HttpPut("{id}")]
16     public async Task<IActionResult> PutGrade(int id, GradeDto dto)
17     {
18         var updated = await _gradesService.UpdateGradeAsync(id, dto);
19         if (!updated) return NotFound();
20         return NoContent();
21     }
22
23     //  DELETE: видалити оцінку
24     [HttpDelete("{id}")]
25     public async Task<IActionResult> DeleteGrade(int id)
26     {
27         var deleted = await _gradesService.DeleteGradeAsync(id);
28         if (!deleted) return NotFound();
29         return NoContent();
30     }


А.2 — NotificationService: створення повідомлень для студента та батьків, nullable-зовнішні ключі в моделі Notification, інтеграція з таблицею ParentStudent. 

 1  public async Task NotifyOnNewGradeAsync(int studentId, int teacherId, int disciplineId, int value)
 2  {
 3      var discipline = await _context.Disciplines
 4          .AsNoTracking()
 5          .FirstOrDefaultAsync(d => d.DisciplineID == disciplineId);
 6
 7      var disciplineName = discipline?.Name ?? "невідома дисципліна";
 8
 9      // Сповіщення для студента
10      _context.Notifications.Add(new Notification
11      {
12          StudentID = studentId,
13          TeacherID = teacherId,
14          Text = $"Нова оцінка: {value} з дисципліни \"{disciplineName}\"",
15          Date = DateTime.UtcNow
16      });
17
18      // Отримати всіх валідних батьків
19      var parentIds = await _context.ParentStudents
20          .Where(ps => ps.StudentID == studentId)
21          .Join(_context.Parents,
22                ps => ps.ParentID,
23                p => p.ParentID,
24                (ps, p) => p.ParentID)
25          .ToListAsync();
26
27      foreach (var parentId in parentIds)
28      {
29          _context.Notifications.Add(new Notification
30          {
31              ParentID = parentId,
32              StudentID = studentId,
33              TeacherID = teacherId,
34              Text = $"Дитина отримала оцінку: {value} з дисципліни \"{disciplineName}\"",
35              Date = DateTime.UtcNow
36          });
37      }
38
39      await _context.SaveChangesAsync();
40  }
}

А.3 — Реєстрація сервісів у Program.cs через AddScoped та підключення DbContext через AddDbContext. 

 1 // Реєстрація DbContext з MySQL
 2 builder.Services.AddDbContext<ArtProgressContext>(options =>
 3 {
 4     var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
 5     options.UseMySql(connectionString, new MySqlServerVersion(new Version(8, 0, 30)));
 6 });
 7
 8 // Реєстрація сервісів
 9 builder.Services.AddScoped<GradesService>();
10 builder.Services.AddScoped<NotificationService>();
11 builder.Services.AddScoped<AdminService>();


А.4 — Розрахунок середнього балу студента та рейтингу групи в GradesService (методи GetStudentAverageAsync, GetGroupAveragesAsync, GetGroupRankingAsync). 

 1  // Середній бал студента
 2  public async Task<double> GetStudentAverageAsync(int studentId)
 3  {
 4      var values = await _context.Grades
 5          .Where(g => g.StudentID == studentId)
 6          .Select(g => g.Value)
 7          .ToListAsync();
 8
 9      return values.Count == 0 ? 0.0 : Math.Round(values.Average(), 2);
10  }
11
12  // Середні бали по групі
13  public async Task<Dictionary<int, double>> GetGroupAveragesAsync(string group)
14  {
15      var students = await _context.Students
16          .Where(s => s.Group == group)
17          .Select(s => new
18          {
19              s.StudentID,
20              Values = s.Grades.Select(g => g.Value)
21          })
22          .ToListAsync();
23
24      var result = new Dictionary<int, double>();
25      foreach (var s in students)
26      {
27          var avg = s.Values.Any() ? Math.Round(s.Values.Average(), 2) : 0.0;
28          result[s.StudentID] = avg;
29      }
30      return result;
31  }
32
33  // Рейтинг групи
34  public async Task<List<(int StudentId, double Average)>> GetGroupRankingAsync(string group)
35  {
36      var data = await _context.Students
37          .Where(s => s.Group == group)
38          .Select(s => new
39          {
40              s.StudentID,
41              Avg = s.Grades.Any() ? s.Grades.Average(g => g.Value) : 0.0
42          })
43          .ToListAsync();
44
45      return data
46          .OrderByDescending(x => x.Avg)
47          .Select(x => (x.StudentID, Math.Round(x.Avg, 2)))
48          .ToList();
49  }

    

А.5 — Консольний IoT-клієнт:  Налаштування HTTP-клієнта

1  var client = new HttpClient();
2  client.BaseAddress = new Uri("https://localhost:7033/api/"); // порт вашого бекенду
3
4  // Асинхронне отримання даних
5  var parents = await client.GetFromJsonAsync<List<Parent>>("parents");
6
7  // Асинхронне надсилання даних
8  var response = await client.PostAsJsonAsync("parents", new ParentDto { Name = "Ім'я", ContactInfo = "Контакт" });

A.6 –  Консольний IoT-клієнт: Додавання нового батька (AddParent)

1  static async Task AddParent(HttpClient client)
2  {
3      Console.Write("Введіть ім'я батька: ");
4      string name = Console.ReadLine();
5      Console.Write("Введіть контактну інформацію: ");
6      string contact = Console.ReadLine();
7
8      var newParent = new ParentDto
9      {
10         Name = name,
11         ContactInfo = contact
12     };
13
14     try
15     {
16         var response = await client.PostAsJsonAsync("parents", newParent);
17         if (response.IsSuccessStatusCode)
18             Console.WriteLine("Батька успішно додано!");
19         else
20             Console.WriteLine("Помилка при додаванні батька: " + response.StatusCode);
21     }
22     catch (Exception ex)
23     {
24         Console.WriteLine("Помилка при додаванні батька: " + ex.Message);
25     }
26 }

A.7 –  Консольний IoT-клієнт: Показ оцінок (ShowGrades)

1  static async Task ShowGrades(HttpClient client)
2  {
3      try
4      {
5          var grades = await client.GetFromJsonAsync<List<Grade>>("grades");
6          Console.WriteLine("Список оцінок:");
7          foreach (var g in grades)
8          {
9              Console.WriteLine($"ID: {g.GradeID}, StudentID: {g.StudentID}, TeacherID: {g.TeacherID}, DisciplineID: {g.DisciplineID}, Оцінка: {g.Value}");
10         }
11     }
12     catch (Exception ex)
13     {
14         Console.WriteLine("Помилка при отриманні оцінок: " + ex.Message);
15     }
16 }

A.8 –   Консольний IoT-клієнт: Бізнес-логіка - обчислення середнього балу студентів 

1   static async Task ShowAverageGrades(HttpClient client)
2   {
3       try
4       {
5           var grades = await client.GetFromJsonAsync<List<Grade>>("grades");
6           if (grades.Count == 0) 
7           { 
8               Console.WriteLine("Оцінок немає"); 
9               return; 
10          }
11          double avg = grades.Average(g => g.Value);
12          Console.WriteLine($"Середній бал студентів: {avg:F2}");
13      }
14      catch (Exception ex)
15      {
16          Console.WriteLine("Помилка при обчисленні середнього балу: " + ex.Message);
17      }
18  }

A.9 –  Консольний IoT-клієнт: Бізнес-логіка - підрахунок кількості сповіщень по батьках 

1   static async Task ShowNotificationsCountByParent(HttpClient client)
2   {
3       try
4       {
5           var notifications = await client.GetFromJsonAsync<List<Notification>>("notifications");
6           var grouped = notifications.GroupBy(n => n.ParentID);
7           foreach (var group in grouped)
8           {
9               Console.WriteLine($"ParentID: {group.Key}, кількість сповіщень: {group.Count()}");
10          }
11      }
12      catch (Exception ex)
13      {
14          Console.WriteLine("Помилка при підрахунку сповіщень: " + ex.Message);
15      }
16  }

A.12 – Налаштування базової адреси сервера

1 Console.Write("Введіть адресу сервера (або Enter для localhost): ");
2 string? serverAddress = Console.ReadLine();
3 if (string.IsNullOrWhiteSpace(serverAddress))
4 {
5     client.BaseAddress = new 
6 Uri("https://localhost:7033/api/");
7 }
8 else
9 {
10     client.BaseAddress = new Uri(serverAddress);
11 }
12 
13 try
14 {
15     var response = await client.GetAsync("ping");
16     response.EnsureSuccessStatusCode();
17     Console.WriteLine("Підключення до сервера встановлено успішно.");
18 }
19 catch (HttpRequestException)
20 {
21     Console.WriteLine("Помилка підключення до сервера. Перевірте адресу або доступність сервера.");
22 }
